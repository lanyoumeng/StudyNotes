## 做题

**列出所有状态**





## 常见概念

### 等差等比

等差：

<img src="https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202410081211609.png" alt="image-20241008121129386" style="zoom: 67%;" />

等比：

![image-20241008121004752](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202410081210025.png)



### 序列

子串(段)：原序列中**必须连续**的一段 

子序列：原序列中**可以不连续**的一段 注意：元素的**顺序都是原序列中的顺序**



### &&

逻辑与运算符 `&&` 是 C++ 中的一种逻辑运算符，用于判断两个表达式的逻辑与（and）关系。在 C++ 中，它有以下特性：

1. **短路求值**：如果逻辑与运算符 `&&` 的左操作数为 `false`（0），则右操作数将不会被计算，因为整个表达式已经为 `false`，无论右操作数的值是什么，最终结果都将为 `false`。这种特性称为短路求值。

```C++
if (condition1 && condition2) {
    // 如果 condition1 为 false，则 condition2 不会被计算
}
```

1. **返回值**：逻辑与运算符返回其右侧操作数的值，但只有当左操作数为 `true`（非零）时，右操作数才会被计算并返回其结果；否则返回 `false`（0）。

题目：[求1+2+3+...+n_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=23248&ru=%2Fpractice%2F11662ff51a714bbd8de809a89c481e21&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D13)

-负号 -100= (-1) *100



### 引用

在 C++ 中，引用是一个别名，用于给一个已经存在的变量起一个新的名字。引用在声明时使用 `&` 符号，可以用于简化代码和提高可读性。以下是关于引用的一些重要点：

1. 引用的声明

```C++
int x = 10;
int& ref = x; // 声明了一个整型引用 ref，它是变量 x 的别名
```

1. 引用的特性

- 引用必须在声明时初始化，之后不可再引用其他变量。
- 一旦引用被初始化，它将一直引用该变量，不能改变指向其他变量。
- 修改引用的值，实际上就是修改了其所指向变量的值。

1. 用途

- 作为函数参数，可以避免函数对参数的复制，提高效率。
- 在函数返回值中，可以返回函数内部变量的引用，避免了拷贝构造函数的调用。

1. 引用和指针的区别

- 引用必须在声明时初始化，并且不能改变指向其他变量；指针可以在声明后改变指向的地址。
- 引用不存在空引用的问题，而指针可以是空指针。
- 引用更符合直觉，因为其行为更像一个变量而非一个对象，而指针则像一个对象。

```C++
void func(int& ref) {
    ref = 20;
}

int main() {
    int x = 10;
    int& ref = x;

    cout << "x: " << x << endl; // 输出：x: 10
    cout << "ref: " << ref << endl; // 输出：ref: 10

    func(ref);

    cout << "x after func: " << x << endl; // 输出：x after func: 20
    cout << "ref after func: " << ref << endl; // 输出：ref after func: 20

    return 0;
}
```

引用可以带来方便和简洁性，但也需要小心使用，确保在使用时理解其行为。



### 递推与递归与动态规划

**递归（Recursion）**是一种通过函数调用自身来解决问题的方法。在递归过程中，问题被分解为更小的相似子问题，并且重复调用函数本身来解决这些子问题，直到达到最小规模的问题，即递归的终止条件。递归在许多算法和数据结构中都有应用，如树的遍历、动态规划等。

**递推（Iteration）**是通过循环迭代来解决问题的方法。它从初始状态开始，通过不断地更新状态和利用已知结果来推导出更复杂的问题的解。递推一般使用循环结构，适合解决一些需要重复计算的问题，例如斐波那契数列等。

从前往后求解是递推，从后往前求解是递归；

**由已知到未知是递推，由未知到已知是递归。**



**动态规划（Dynamic Programming）**是一种解决复杂问题的方法，它通过将问题分解为更小的子问题，然后将子问题的解缓存起来，避免重复计算，最终得到原问题的解。动态规划常用于需要最优化的问题，例如最长公共子序列、背包问题等。

这三种方法各有优劣和适用场景。递归通常思路简单清晰，但可能会因为重复计算而效率较低；递推以迭代的方式解决问题，适合解决简单的迭代问题；动态规划在空间换时间的基础上，能够解决某些复杂问题，但需要理解问题的特性来设计状态转移方程。

在实际应用中，选择合适的方法取决于问题的特性和要求，有时也可以将它们结合起来使用。



## C++基础语法



#### 函数

##### 自定义排序函数

```c++
   // 1.使用 lambda 表达式按降序排序
    std::sort(vec.begin(), vec.end(), [](int a, int b) {
        return a > b;  // 降序排列：如果 a > b，则 a 在 b 前面
    });

  // 2.自定义比较函数进行多条件排序
bool multiConditionCompare(const Student& s1, const Student& s2) {
    if (s1.score == s2.score) {
        return s1.name < s2.name;  // 分数相同时按名字升序排列
    }
    return s1.score > s2.score;  // 按分数降序排列
}

int main() {
    std::vector<Student> students = {
        {"Alice", 90}, {"Bob", 90}, {"Charlie", 95}, {"David", 85}
    };

    // 使用自定义比较函数进行排序
    std::sort(students.begin(), students.end(), multiConditionCompare);
```





##### log

ln=log (double x)

lg=log10 (double x)

loga(b)=log(b)/log(a)

```C++
#define e 2.71828
    cout << log(4) / log(2);
```



##### 二分函数

lower_bound(first, last, value)

▸ first：查找起始位置（指针或 iterator）

▸ last：查找终⽌位置（指针或 iterator）

▸ value：查找的值



▸ lower_bound 查找的范围是 [first, last)，返回的是序列中第⼀个**大于等于** value 的元素的位置，时间为 O(logn)

▸ [first, last)范围内的序列必须是**提前排好序**的，不然会错

▸ 如果序列内所有元素都⽐ value ⼩，则返回last
 upper_bound(first, last, value)

▸ upper_bound 与 lower_bound 相似，唯⼀不同的地⽅在于upper_bound 查找的是序列中第⼀个⼤于 value 的元素



```C++
int main()
{
    int arr[]={3,2,5,1,4};
    sort(arr,arr+5);//需要先排序
    cout << *lower_bound(arr,arr+5,3);//输出数组中第一个大于等于3的值
    return 0;
}

1.lower_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于等于key的第一个值的位置
2.upper_bound(v.begin(), v.end(), key)-v.begin()返回有序序列中大于key的第一个值的位置
3.lower_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于等于key的第一个值的位置
4.upper_bound(v.begin(), v.end(), key, greater<int>())-v.begin()返回有序序列中小于key的第一个值的位置
5.上述四个函数，若无满足条件的值，则返回 v.end()       
6. *lower_bound(v.begin(), v.end(), key)   返回数字
```

##### memset

memset 置long long数组比置int数组时间长

```C++
 memset(a, 0x3f, sizeof(a));   INF
 memset(a, 0xcf, sizeof(a));   -INF
```

##### 快读

```C++
inline int read()
{
    char c = getchar();  //c当前输入
    int x = 0, s = 1; //x数值  s符号
    while (c < '0' || c > '9')
    {
        if (c == '-')
            s = -1;
        c = getchar();
    } //是符号
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    } //是数字
    return x * s;
}
```



##### 增强for

```C++
遍历的整个数组
第一种：for(auto a:arr)
第二种：for(auto &a:arr) //可以改变   cin>>a;  
```



##### 三目运算符

if else语句简化 函数return



##### 全排列

```C++
int ex = 3, a[100];
    for (int i = 1; i <= ex; i++)
    {
        a[i] = i;
    }

    do
    {
        for (int i = 1; i <= ex; i++) // 修改这里的条件
        {
            cout << a[i];
        }
        cout << "\n";

    } while (next_permutation(a + 1, a + ex + 1));
```



##### unique

用于在范围内移除连续重复的元素。 它并不真正删除元素，而是将重复的元素移到范围的末尾，并
返回一个迭代器，指向不重复序列的末尾

```C++
        std::vector<int> a= {1, 3,, 5,4,0, 3, 2,  5};  
        
        sort(a,a+n); //由于它”删除”的是相邻的重复元素,需要在执行unique函数之前先对数组进行排序
        auto it = unique(a,a+n); //迭代器it指向第一个重复元素的下标
        int m= unique(a,a+n)-a;  //m代表去重后数组大小
        a.erase(it, a.end());  // 使用erase删除重复的元素
        
        numbers.erase(a.begin() + 2); // 删除第三个元素（下标为2）
```



### 指针

在C++中，当你创建一个指向对象的指针并将其赋值给另一个指针时，这两个指针指向同一个对象。如果你改变了指针本身的值（即，让它指向另一个对象或设置为`nullptr`），不会影响另一个指针的值，因为它们是独立的指针。但是，如果你通过其中一个指针修改了对象的内容，另一个指针也会看到这些修改，因为它们指向同一个对象。

-> 就表示修改指向的对象

处理指向对象的指针时，你应该使用箭头运算符 `->`，当你处理对象本身时，你应该使用点运算符 `.`。

- `.` 是用于**对象实例**或**引用**，例如 `person.name`。
- `->` 是用于**指针**，例如 `personPtr->name`。 Person* personPtr = new Person(); 

你可以理解为，`a->b` 相当于 `(*a).b`，即首先解引用指针`a`，然后通过`.`运算符访问对象的成员。





**`&`**：

- **取地址符**：用于获取变量的地址，如 `int* ptr = &x;`
- **引用符**：用于声明引用，引用是原变量的别名，如 `int& ref = x;`

**`\*`**：

- **指针声明符**：用于声明指针变量，如 `int* ptr = &x;`
- **解引用符**：用于访问指针指向的变量值，如 `cout << *ptr << endl;`



### 堆栈

在main函数里面的数组是开在栈区(stack)的，而在函数外面的是开在数据区的。栈区的内存比较小，所以当数组非常大的时候，就会报错。而把数组放在数据区就不会出现这个问题，因为数据区的内存比较的大

- 栈区：由操作系统自动分配释放，存放函数的参数值，局部变量的值，当不需要式系统会自动清除。
- 堆区：由new分配的内存块，不由编译器管，由应用程序控制（相当于程序员控制）。如果程序员没有释放掉，程序结束后，操作系统会自动回收。
- 数据区：也称全局区或者静态区，存放全局的东西类似全局变量。
- 代码区：存放执行代码的地方，类似if else，while，for这种语句。



### 引用



### 结构体



### 整数变浮点数

```C++
 int a = 2, b = 4;
    cout << a / b << " " << a * 1.0 / b;  // 0 0.5
```



## STL

#### 迭代器

```C++
vector<int>::iterator it
vector<int>::iterator it=v.begin();    ==   auto it=v.begin();

在这⾥ it 类似于⼀个指针，指向 v 的第⼀个元素
it 等价于 &v[0]
*it 等价于 v[0]
    
    
    
        // 遍历 vv 向量，将二叉树节点串成链表
        for (auto it = vv.begin(); it != vv.end() - 1; ++it) {
            (*it)->right = *(it + 1); // 将当前节点的右指针指向下一个节点
            (*it)->left = nullptr; // 将当前节点的左指针置空
        }

        // 最后一个节点的左右指针都要置空
        vv.back()->left = nullptr;
        vv.back()->right = nullptr;
```

#### 字符串

```C++
s.substr(i,len) //返回从s的下标i开始的len个字符组成的字符串，如果n省略就取到底O(n)
s.empty() //判断s是否为空，空返回1，不空返回0，O(1)
s1.find(s2,i)   //从字符串下标为i的位置开始寻找子s2 //s1.refind(s2) pos+1开始      找不到==string::npos
s.insert(p0,n,c) //在p0处插入n个字符c O(n)   s1.insert(5, s2);

s.push_back(letter);
s.pop_back();

s.replace(pos, len,  str);//替换指定位置的字符串 pos：替换的起始位置 len：要被替换的字符数 str：用来替换的字符串。
s.replace(first, last,  str); //替换指定迭代器范围

s.erase(i,len) // 删除s中从i(下标)开始的len个字符，如果len省略就删到底O(n)
s.erase(s.begin() + i); // 删除下标为 i 的字符（索引从 0 开始） O(n)
string s=*char; 创建string时直接用字符串内容对其赋值，注意字符串要用双引号""
string s(int n,char c); 创建一个string，由n个c组成，注意c是字符型要用单括号''
    
//读入string
getline(cin,s); 读入s，空格也同样会读入，直到回车才会停止
```

##### string 和 int，long long 互相转换

```C++
int a = stoi(s);  //string->int
int a = stoll(s);  //string->long long 
string s = to_string(a);  //int ->string 
```

stoi函数 作用是将 n 进制的字符串转化为十进制，如果转换成功的话，`stoi`函数将会把转换后的得到数字以`int`类型返回。 定义如下： int stoi( const std::string& str, std::size_t* pos = nullptr, int base = 10 ); 参数： str - 待转换的字符 pos - 其取值可以是一个空字符，在这种情况下，pos未被使用；另外如果pos不是空指针，函数将pos的值设置为str中数字后面的第一个字符的位置。 base - **字符中数字的进制**，默认为10进制，如果base取值为0，则进制由字符串中的格式决定。

```C++
  cout << stoi("456");
```

##### string与字符数组的互相转化

1 string转化为字符数组

```C++
1. string s;
   strcpy(c, s.c_str());
2.for (int i = 0; i < s.length(); i++)
    c[i] = (char)s[i];
```

2 [字符数组](https://so.csdn.net/so/search?q=字符数组&spm=1001.2101.3001.7020)转化为string

```C++
1.直接赋值
char c[] = "sadasds";
    string s = c;
2.+=
```

##### char和int转换

```C++
int char_int(char a)  //if(数字字符) n=n-'0' else n=c-'A'+10  可以传s[i]    s:string
{return a > '0' && a < '9' ? a - '0' : 10 + a - 'A';}
char int_char(int x)
{return x < 10 ? x + '0' : x  + 'A'- 10;}
```



#### Vector

```C++
vector<int> v(n + 1, 0);
// DP 数组
vector<vector<int>> D(n + 1, vector<int>(m + 1,0);

reverse(a.begin(), a.end());

v.pop_back() 删除 v 最后⼀个元素 O(1)
v.resize(int n) 把 v 的⻓度设定为 n 个元素 O(n)
v.insert(iterator it,type x)向迭代器it指向元素 前增加一个元素x,O(n)
v.erase(iterator it) 删除向量中迭代器指向元素,O(n)
v.front()返回首元素的引用O(1)
v.back()返回尾元素的引用O(1)

v.end()返回尾迭代器，指向向量最后一个元素的下一个位置O(1)
```

#### stack

```C++
s.push(x); // ⼊栈
s.pop(); // 出栈
s.top(); // 访问栈顶
s.empty(); // 当栈空时，返回true
s.size(); // 访问栈中元素个数
```

#### deque 双端队列

```C++
 reverse(a.begin(), a.end());

push_back();          //在队列末尾增加一个元素， 参数为拷贝或移动的元素
push_front();          //在队列头部增加一个元素，参数可以是拷贝或移动的元素
pop_front();                //*从队列头部移除第一个元素*
pop_back();                //*从队列尾部移除最末尾的元素* 
emplace();                 //在队列指定的元素位置前插入新的元素
erase();                          //从队列指定的元素位置删除元素，可以指定一个范围删除。 dq.erase(dq.begin()+2, dq.end()-2);
clear();                           //  *清空队列所有元素，size将为0*

insert();                //在队列任一元素前增加新的元素

begin();                //*从队列返回第一个元素的位置指针* 
end();                  //从队列返回最后一个元素的结束位置，但不是最后一个元素位置
at()                        // 在队列中返回指定索引元素的引用
size()                //返回队列中元素的个数
```

#### pair

排序规则:先照key排，再按照value排序

#### map

map中存储的是key-value键值对，默认按照key值从小到大顺序排序 map<string,int> m; m[lplp]=321;

```C++
map<int, list<int>> xx, yy;  
xx[x].push_back(y);
//遍历方法：
for(auto i:mp)
    cout<<i.first<<' '<<i.second<<endl;
map.count()  key 存在，返回 1，key 不存在，返回 0。
mp.find(key)：在 mp 中查找⼀个 key 并返回其 iterator，找不到的话返回 s.end() O(logn)
mp.erase(key): 在 mp 中删除 key 所在的项，key和value都会被删除 O(logn)
mp.lower_bound(item)：返回 mp 中第一个key大于等于item的迭代器，找不到就返回mp.end() O(logn)
mp.upper_bound(item)：返回 mp 中第一个key大于item的迭代器，找不到就返回mp.end() O(logn)
    
mp[key]：返回 mp 中 key 对应的 value。如果key 不存在，则返回 value 类型的默认构造器（defaultconstructor）所构造的值，并该键值对插⼊到 mp 中O(logn)

//
map<vector<int>, int> A;  //值是一个数组
for (int i = 0; i < n; i++){ 
    for (int j = 0; j < m; j++)
        scanf("%d", &temp[j]);
        A[temp]++;}

multimap<int, vector<int>, greater<int>> B;  //排序
  for (auto it : A)
        B.insert({it.second, it.first});
```

#### 哈希unordered

set和map都可以在前面加上unorder_使得内部的元素改成不按顺序存储的，其余的功能都不改变，虽然无法顺序存储，但底层原理是hash，可以使得所有的查询、修改、删除操作都变成O(1)复杂度

在C++中是一个十分有用的数据结构，它通过将键映射到值的方式，可以帮助快速查找和访问数据。在C++中，可以使用 `unordered_map`（无序映射）来实现哈希表。

```C++
cppCopy code#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // 创建一个哈希表，将字符串映射到整数值
    unordered_map<string, int> hashTable;

    // 插入键值对
    hashTable["apple"] = 5;
    hashTable["banana"] = 10;

    // 查找键对应的值
    cout << "Value of apple: " << hashTable["apple"] << endl;

    // 检查某个键是否存在
    if (hashTable.find("banana") != hashTable.end()) {
        cout << "banana is in the hash table" << endl;
    }

    // 删除键值对
    hashTable.erase("apple");

    return 0;
}
```

在 C++ 中，`std::map` 是基于红黑树实现的关联容器，而 `std::unordered_map` 是基于哈希表实现的关联容器。

`std::map` 和 `std::unordered_map` 都是用于存储键值对的容器，但它们的内部实现方式不同，这也影响了它们的特性和性能。

- `std::map` 会根据键的比较结果进行排序，因此其内部实现是基于平衡二叉搜索树（通常是红黑树），这样的话插入和查找操作的时间复杂度是 O(log n)。
- `std::unordered_map` 使用哈希表实现，通过哈希函数将键映射到存储桶中，允许常数时间的插入和查找操作，时间复杂度为 O(1)，但最坏情况下可能会退化为 O(n)。

虽然 `std::unordered_map` 是基于哈希表的实现，但是 `std::map` 并不直接使用哈希函数。如果你需要哈希表的特性，比如快速的查找、插入和删除操作，并且不关心元素的顺序，那么 `std::unordered_map` 更适合你。

但如果你需要元素按照某种顺序进行存储和遍历（比如按照键的排序），那么 `std::map` 可能更适合你的需求。

#### 优先队列

```C++
重新定义排列顺序   //默认的是大根堆（顶部是最大数）
1.priority_queue<int, vector<int>, greater<int>> q;//改为小根堆
2.struct Node{
    int x,y;
};
bool operator<(Node a,Node b){
    return a.x<b.x;
}
 priority_queue<Node> pq;

顶端是q.top();  //不是q.front();
```

#### list

```C++
erase()        删除容器中一个或某区域内的元素。
remove(val)        删除容器中所有等于 val 的元素。
    
front()        返回第一个元素的引用。
back()        返回最后一个元素的引用。   
```

#### set

```C++
//集合(set)是一种包含对象的容器，可以快速地（logn）查询元素是否在已知几集合中。
//set 中所有元素是有序地，且只能出现⼀次，因为 set 中元素是有序的，所以存储的元素必须已经定义 过「<」运算符（因此如果想在 set 中存放 struct 的话必须⼿动重载「<」运算符，和优先队列一样）

//multiset元素有序可以出现多次
//unordered_set元素无序只能出现一次
//unordered_multiset元素无序可以出现多次

使用方法：
s.count(item)：//返回 s 中 item 的数量。在set中因为所有元素只能在 s 中出现⼀次，所以返回值只能是 0 或 1
                      //在multiset中会返回存的个数 O(logn)
s.find(item)：在 s 中查找⼀个元素并返回其迭代器，找不到的话返回 //s.end() O(logn)
s.insert(item)：在 s 中插⼊⼀个元素 O(logn)
s.begin()：返回 s 中最小元素的迭代器，注意set中的迭代器和vector中的迭代器不同，无法直接加上某个数，因此要经常用到--和++O(1)

    
s.erase(position)：删除 s 中迭代器position对应位置的元素O(logn)
s.erase(item)：删除 s 中对应元素 O(logn)
s.erase(pos1, pos2)：删除 [pos1, pos2) 这个区间的位置的元素 O(logn + pos2 - pos1)

s.lower_bound(item)：返回 s 中第一个大于等于item的元素的迭代器，找不到就返回s.end() O(logn)
s.upper_bound(item)：返回 s 中第一个大于item的元素的迭代器，找不到就返回s.end() O(logn)
```

#### bitset

```C++
const int MAXN = 32;
bitset<MAXN> bt; // bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0
bitset<MAXN> bt1(0xf); // 0xf 表示⼗六进制数 f，对应⼆进制 1111，将 bt1 低 4 位初始化为 1
bitset<MAXN> bt2(012); // 012 表示⼋进制数 12，对应⼆进制 1010，
// 即将 bt2 低 4 位初始化为 1010
bitset<MAXN> bt3("1010"); // 将 bt3 低 4 位初始化为 1010
bitset<MAXN> bt4(s, pos, n); // 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4

bitset<n>b(unsigned long u);
bitset<n>b(string s);//将由'0'和'1'组成的字符串赋值给
                        支持所有位操作：| |= & &= << <<= >> >>=
cout<<b;//bitset可以直接用cout输出
b[index];//可以用下标操作符来读或写某个索引位置的二进制位
比如bitset<10>b(5) 等价于 bitset<10>b("1010")
其中cout<<b输出0000001010
for(int i=0;i<10;i++)cout<<b[i];输出0101000000   //坐标从后往前计数，高位在前



bt.count() // bt 中置为 1 的⼆进制位的个数
bt.size() // bt 中⼆进制位的个数 ,求bitset的大小
bt.test(pos) // bt 中在 pos 处的⼆进制位是否为 1
bt.flip()  bt[pos].flip()    bt.flip(pos) // 所有⼆进制位取反    pos 处的⼆进制位取反
    
string s = foo.to_string();//将bitset转换成string类型
unsigned long a = foo.to_ulong();//将bitset转换成unsigned long类型
unsigned long long b = foo.to_ullong();//将bitset转换成unsigned long long类型 

b.any();//any函数检查bitset中是否有１
b.none();//none函数检查bitset中是否没有１
   
bt.set()  bt.set(pos) //所有⼆进制位都置为 1     pos 处的⼆进制位置为 1 
bt.reset() bt.reset(pos) // ⼆进制位都置为 0    pos处的⼆进制位置为0
os << bt // 把 bt 中的位集输出到 os 流
```

------

## 数据结构

### 链表

1. **虚拟头节点、虚拟尾结点** 十分有用 ，关键是有一个意识，去想象”空“的存在，链表的前和后都有”空“的存在，而尾节点更是指向”空“

   ```c++
   ListNode* pre = new ListNode(-1);
   ListNode* preHead = pre;
   
   
   ```

   

2. ->next和->next->next  可以先用额外变量存储起来

3. **首尾节点判断时特殊处理**

```
    ListNode* dummy = new ListNode(0); // 创建一个虚拟头节点，方便处理
   
   // 翻转当前组的k个节点
    ListNode* prev = nullptr;
    ListNode* curr = groupStart;
    for (int i = 0; i < k; i++) {
        ListNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }
    
    // 合并两个有序链表
    ListNode* merge(ListNode* node1, ListNode* node2) {
        ListNode* head = new ListNode(); // 哨兵节点
        ListNode* now = head;
        
        // 合并两个链表
        while (node1 && node2) {
            if (node1->val <= node2->val) {
                now->next = node1;
                node1 = node1->next;
            } else {
                now->next = node2;
                node2 = node2->next;
            }
            now = now->next;
        }
        
        // 剩下的节点直接接到末尾
        if (node1) {
            now->next = node1;
        }
        if (node2) {
            now->next = node2;
        }

        return head->next; // 返回真正的头节点
    }
    
    
            // 分治法合并链表
        int interval = 1;
        while (interval < lists.size()) {
            for (int i = 0; i + interval < lists.size(); i += interval * 2) {
                lists[i] = merge(lists[i], lists[i + interval]);
            }
            interval *= 2;
        }
```



### 二叉树

节点深度从1开始

满二叉树：
$$
n = 2^h - 1
$$
如果给定一棵完全二叉树的节点总数 \( n \)，则可以通过如下公式近似计算其深度 \( h \)：


$$
h = \lfloor \log_2(n) \rfloor + 1
$$
1.最后一个非叶子结点 ---> arr.length/2-1 //数组从0开始

```C++
const int Max = 2e5 + 10;
struct Node
{
    int val,l, r;
} t[Max];
int n;

void build()
{
    for (int i = 1; i <= n; i++)  //节点编号从1开始
    {
        cin >> t[i].l >> t[i].r;
    }
}

int dfs(int x) // 深度遍历
{
    if (!x)   return 0;
    return max(dfs(t[x].l), dfs(t[x].r)) + 1;
}


int main()
{
    cin >> n;
    build();
    cout << dfs(1);
    return 0;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution
{
public:
    vector<int> printFromTopToBottom(TreeNode *root) ///层次遍历
    {
        queue<TreeNode *> q;
        vector<int> r;
        q.push(root);
        while (!q.empty())
        {
            TreeNode *f = q.front();
            q.pop();
            if (f != NULL)
                r.push_back(f->val), q.push(f->left), q.push(f->right);
        }
        return r;
    }
};
// 前序遍历
void preorder(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    cout << root->val << " "; // 访问根节点
    preorder(root->left);     // 遍历左子树
    preorder(root->right);    // 遍历右子树
}

// 中序遍历
void inorder(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    inorder(root->left);      // 遍历左子树
    cout << root->val << " "; // 访问根节点
    inorder(root->right);     // 遍历右子树
}

// 后序遍历
void postorder(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    postorder(root->left);    // 遍历左子树
    postorder(root->right);   // 遍历右子树
    cout << root->val << " "; // 访问根节点
}
```

判断根节点： 用 has_father[r[i]] = true; 标记左右结点是否有父节点 在遍历标记数组，没有父节点的就是根节点。

#### LCA

```C++
    TreeNode* LCA(TreeNode* root, int o1, int o2) {
        if (root == nullptr || root->val == o1 || root->val == o2) {
            return root;
        }
        TreeNode* l = LCA(root->left, o1, o2);
        TreeNode*  r = LCA(root->right, o1, o2);
        if (l == nullptr) {
            return r;
        }
        if (r == nullptr) {
            return l;
        }
        return root;
    }
```



### 堆

堆其实就是利用完全二叉树的结构来维护一个数组，但堆并不一定是完全二叉树。

[大顶堆](https://so.csdn.net/so/search?q=大顶堆&spm=1001.2101.3001.7020)：每个结点的值都**大于**或**等于**其左右孩子结点的值；arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2] 小顶堆：每个结点的值都**小于**或**等于**其左右孩子结点的值。arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]

#### 建堆

#### **堆排序**

[堆排序](https://so.csdn.net/so/search?q=堆排序&spm=1001.2101.3001.7020)的基本思想：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```C++
#include <bits/stdc++.h>
using namespace std;

int nums[1000], n;

void heapsmall(int len, int index) // index 非叶子结点   函数只检查根节点、左右子结点的最小  以及某一子节点的后续
{
    int min = index;
    while (true)
    {
        if (index * 2 + 1 < len && nums[index * 2 + 1] < nums[index])
        {
            min = index * 2 + 1;
        }
        if (index * 2 + 2 < len && nums[index * 2 + 2] < nums[min])
        {
            min = index * 2 + 2;
        }
        if (min == index)
            break;

        swap(nums[index], nums[min]);
        // 从交换后的节点开始继续往下堆化
        index = min;
    }
}

void buildHeap(int k) // k节点数
{
    // heapsmall(k, 0);
    for (int i = k / 2 - 1; i >= 0; i--)
    {
        heapsmall(k, i); // i最后一个非叶子结点
    }
}

void heapsort(int nums[], int k)
{
    for (int i = k - 1; i > 0; i--)
    {
        swap(nums[0], nums[i]);
        heapsmall(i, 0);
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> nums[i];
    buildHeap(n);
    heapsort(nums, n);
    for (int i = 0; i < n; i++)
    {
        cout << nums[i] << endl;
    }
    return 0;
}
```

## 基础算法

#### 模拟

#### 递推

##### 递推求组合 C[i] [j]

```C++
//也就是杨辉三角   
 for (int i = 0; i < 20; i++)
    {   c[i][0] = c[i][i] = 1;
        for (int j = 1; j < i; j++)
                           c[i][j] = c[i - 1][j] + c[i - 1][j - 1];   }//递推公式 
```

##### 数组第i到n-1位最大的数

```C++
 for (int i = n - 1; i >= 0; i--)
    {
        b[i] = max(a[i], b[i + 1]);
    }//b[i] 第i到n-1位最大的数    全局 int a[N],b[N];
```

#### 递归、回溯



#### 二分

1.二分查找：例：大于X的最小值

check()保证大于x ，向左移保证最小值

2.二分答案：

复杂度为 O(log n)

```C++
模板一：//尽量往左找目标
bool check(int x) {/* nums[mid] >= target  ... */} // 检查x是否满足某种性质

while (l < r)
{
    int mid = (l + r) >> 1;        //(l+r)/2
    // if(nums[mid]==target){ return ...}  // 不知道l,r 是+/- 1时好用
    if (check(mid))  r = mid;    // check()判断mid是否满足性质
    else l = mid + 1;
}
// if (target == nums[l]) { return l;}


模板二：尽量往右找目标
while (l < r)
{
    int mid = (l + r + 1 )>> 1;        //(l+r+1)/2
    if (check(mid))  l = mid;
    else r = mid - 1;
}
模板3：（浮点二分）
while(r-l>1e-6) //需要一个精度保证
{
        double mid = (l+r)/2;
        if(check(mid)) l=mid; //或r=mid;
        else r=mid; //或l=mid;
}
```



#### 贪心

贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。

贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。

**动态规划**主要运用于**二维或三维**问题，而**贪心**一般是**一维**问题。

#### 排序

##### 常用排序算法



| 排序算法 | 平均时间复杂度 | 最优时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| -------- | -------------- | -------------- | -------------- | ---------- | -------- |
| 冒泡排序 | O(n²)          | O(n)           | O(n²)          | O(1)       | 是       |
| 插入排序 | O(n²)          | O(n)           | O(n²)          | O(1)       | 是       |
| 选择排序 | O(n²)          | O(n²)          | O(n²)          | O(1)       | 否       |
| 归并排序 | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | 是       |
| 快速排序 | O(n log n)     | O(n log n)     | O(n²)          | O(log n)   | 否       |
| 堆排序   | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | 否       |
| 希尔排序 | O(n^(3/2))     | O(n log n)     | O(n²)          | O(1)       | 否       |
| 计数排序 | O(n + k)       | O(n + k)       | O(n + k)       | O(k)       | 是       |
| 桶排序   | O(n + k)       | O(n + k)       | O(n²)          | O(n + k)   | 是       |
| 基数排序 | O(d(n + k))    | O(d(n + k))    | O(d(n + k))    | O(n + k)   | 是       |



1. 冒泡排序（Bubble Sort）

- **思想**：重复地遍历待排序的数组，每次比较相邻元素并交换顺序不正确的元素，直到整个数组有序。
- **时间复杂度**：
  - 最优：O(n)（当输入数据已经有序时）
  - 平均：O(n²)
  - 最坏：O(n²)
- **空间复杂度**：O(1)
- **是否稳定**：是

2. 插入排序（Insertion Sort）

- **思想**：每次将一个元素插入到已经排好序的序列中，直到所有元素插入完毕。
- **时间复杂度**：
  - 最优：O(n)（当输入数据已经有序时）
  - 平均：O(n²)
  - 最坏：O(n²)
- **空间复杂度**：O(1)
- **是否稳定**：是

3. 选择排序（Selection Sort）

- **思想**：每次从未排序的序列中选择最小（或最大）元素，并将其放到已排序序列的末尾。
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)
- **是否稳定**：否

4. 归并排序（Merge Sort）

- **思想**：采用分治策略，将数组分成两个子数组，对两个子数组分别排序，然后合并排序好的子数组。
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **是否稳定**：是

5. 快速排序（Quick Sort）

- **思想**：选择一个基准元素，将数组分成两部分，一部分小于基准元素，一部分大于基准元素，然后递归排序这两部分。
- **时间复杂度**：
  - 最优：O(n log n)
  - 平均：O(n log n)
  - 最坏：O(n²)（当每次选择的基准元素是最大或最小值时）
- **空间复杂度**：O(log n)（递归栈空间）
- **是否稳定**：否

6. 堆排序（Heap Sort）

- **思想**：利用堆这种数据结构进行排序。首先构建一个最大堆，然后依次将堆顶元素与未排序部分的最后一个元素交换，并对剩余部分重新调整堆结构。
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(1)
- **是否稳定**：否

7. 希尔排序（Shell Sort）

- **思想**：是一种改进版的插入排序。通过将数组元素按一定间隔分组，然后对每组进行插入排序，随着间隔逐渐减少，直到间隔为 1。
- **时间复杂度**：
  - 最优：O(n log n)
  - 平均：O(n^(3/2))
  - 最坏：O(n²)
- **空间复杂度**：O(1)
- **是否稳定**：否

8. 计数排序（Counting Sort）

- **思想**：利用额外数组统计每个元素出现的次数，然后按计数结果将元素放回原数组。
- **时间复杂度**：O(n + k)（其中 k 为输入元素的最大值）
- **空间复杂度**：O(k)
- **是否稳定**：是

9. 桶排序（Bucket Sort）

- **思想**：将数组分到有限数量的桶中，对每个桶分别排序，然后依次合并桶内数据。
- **时间复杂度**：
  - 最优：O(n + k)
  - 平均：O(n + k)
  - 最坏：O(n²)（当所有元素分到一个桶时）
- **空间复杂度**：O(n + k)
- **是否稳定**：是

10. 基数排序（Radix Sort）

- **思想**：将整数按位数拆分，然后按每个位进行排序，从最低位到最高位，最终完成排序。
- **时间复杂度**：O(d * (n + k))（其中 d 是位数，k 是基数）
- **空间复杂度**：O(n + k)
- **是否稳定**：是





##### 快排



```C++
void quick_sort(int q[], int l, int r)
{
//递归的终止情况
if (l >= r) return;
//选取分界线。这里选数组中间那个数
int i = l - 1, j = r + 1, x = q[l + r >> 1];
//划分成左右两个部分
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
//对左右部分排序
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

边界问题 因为边界问题只有这两种组合，不能随意搭配

```C++
//x不能取q[l]和q[l+r>>1];
quick_sort(q,l,i-1),quick_sort(q,i,r);

//x不能取q[r]和q[(l+r+1)>>1];
quick_sort(q,l,j),quick_sort(q,j+1,r);
```

##### 归并排序

```C++
int a[N], tmp[N];
void merge_sort(int q[], int l, int r)
{
    //递归出口
    if (l >= r) return;
    
    //第一步，分成两个子区间
    int mid =  l + r >> 1;
    
    //第二部，递归处理子区间
    //要注意这里用的mid和mid+1来划分两区间，建议不要用mid-1和mid来划分
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    
    //第三步，合并排序好的子区间
    //tips：k为temp下标，i和j为两个子区间起始位置
    int k = 0, i = l, j = mid + 1;
    //排序好的两边取大小，暂存数组temp挑小的取
    while (i <= mid && j <= r) 
    {
        if (q[i] <= q[j]) temp[k++] = q[i++];
        else temp[k++] = q[j++];
    }
    //很可能存在有一子区间没有比较完，由于该区间是排好序的，后面的没比较完，说明都是最大的，直接往temp后面加即可。
    while (i <= mid) temp[k++] = q[i++];
    while (j <= r) temp[k++] = q[j++];
    //在[l, r]范围中，将temp数组存的有序值赋给q数组完排序，注意<=r的等号不要漏
    for (int i = l, j =0; i <= r; i++, j++) q[i] = temp[j];
}
```

##### 比较

归并排序虽然是稳定的，但在实际应用中快排更常用，主要原因包括：

1. **空间开销较小**
    快速排序是原地排序（in-place），只需要 O(log n) 的递归栈空间；而归并排序通常需要额外的 O(n) 空间来合并数据，这在内存受限或大数据量时会成为瓶颈。
2. **平均性能更好**
    快速排序在平均情况下时间复杂度是 O(n log n) 且常数因子较小，利用分区操作能更好地利用缓存（cache locality），使得实际运行速度通常比归并排序快。归并排序在合并阶段会涉及大量数据复制，导致实际性能上略逊一筹。
3. **优化和适应性**
    现代的快排实现（如随机化选取 pivot、三数取中、尾递归优化等）可以有效避免最坏情况，从而稳定地达到较高的效率。此外，在许多场景下稳定性并不是必须的需求，所以快排成为更常见的选择。

因此，尽管归并排序的稳定性在某些场合（如**需要保持相等元素的原始顺序**）很重要，但由于**内存占用和运行效率**上的优势，快排在实际开发中被更广泛使用。




#### 高精度

1.高精度加法

```C++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &a,vector<int> &b){
        vector<int> c;//c为答案
        int t=0; //t为进位
   for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size())t+=a[i];   //不超过a的范围添加a[i]
        if(i<b.size())t+=b[i];  //不超过b的范围添加b[i]  
        c.push_back(t%10);  //取当前位的答案
        t/=10; }         //是否进位
if(t)c.push_back(1);//如果t!=0的话向后添加1
return c;        
}
```

2.高精度减法

```C++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

3.乘法

```C++
//高精度乘低精度  C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

//高精度乘高精度
vector<int> mul(vector<int> &A, vector<int> &B) {
    vector<int> C(A.size() + B.size()); // 初始化为 0，C的size可以大一点
    for (int i = 0; i < A.size(); i++)
        for (int j = 0; j < B.size(); j++)
            C[i + j] += A[i] * B[j];
    for (int i = 0, t = 0; i < C.size(); i++) {
        // i = C.size() - 1时 t 一定小于 10
        t += C[i];
        C[i] = t % 10;
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0
    return C;
}
```

4.除法

```C++
//高精度除以低精度  A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
//高精度除高精度
vector<int> div(vector<int> &A, vector<int> &B, vector<int> &r) {
    vector<int> C;
    if (!cmp(A, B)) {
        C.push_back(0);
        r.assign(A.begin(), A.end());
        return C;
    }
    int j = B.size();
    r.assign(A.end() - j, A.end());
    while (j <= A.size()) {
        int k = 0;
        while (cmp(r, B)) {
            r = sub(r, B);
            k ++;
                   }
        C.push_back(k);
        if (j < A.size())
                r.insert(r.begin(), A[A.size() - j - 1]);
        if (r.size() > 1 && r.back() == 0)
                r.pop_back();
        j++;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0)
            C.pop_back();
    return C;
}
```

##### 1.字符串模拟

##### 2.数组模拟

```C++
#include <bits/stdc++.h>
using namespace std;
struct node
{
    int fir, sec;
    bool operator<(const node &a) const
    {
        return fir * sec < a.fir * a.sec;
    }
} st[1005];
int sum[5050];
int vis[5050];
int arr[5050];
int len = 1, tex = 1;
void cheng(int b)
{
    for (int i = 1; i <= len; i++)
    {
        vis[i] *= b;
    }
    for (int i = 1; i <= len; i++)
    {
        vis[i + 1] += vis[i] / 10;
        vis[i] %= 10;
    }
    
    if (vis[len + 1] != 0)
        len++;
    while (vis[len] > 10)
    {
        vis[len + 1] += vis[len] / 10;
        vis[len] %= 10;
        len++;
    }
}
void chu(int b)
{
    int t = 0, flag = 0, ans = 0;
    for (int i = len; i >= 1; i--)
    {
        t = t * 10 + vis[i];
        if (t < b && flag == 0)
            continue;
        else
        {
            flag = 1;
            arr[++ans] = t / b;
            t %= b;
        }
    }
    // 比较金币数，得到最大金币数。
    if (ans > tex)
    {
        for (int i = 1; i <= ans; i++)
            sum[i] = arr[i];
        tex = ans;
    }
    else
    {
        if (ans == tex)
        {
            for (int i = 1; i <= ans; i++)
            {
                if (arr[i] > sum[i])
                {ww
                    for (int i = 1; i <= ans; i++)
                    {
                        sum[i] = arr[i];
                    }
                    break;
                }
            }
        }
    }
}
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i <= n; i++)
    {
        cin >> st[i].fir >> st[i].sec;
    }
    sort(st + 1, st + 1 + n);
    sum[1] = vis[1] = 1;
    for (int i = 1; i <= n; i++)
    {
        cheng(st[i - 1].fir);
        chu(st[i].sec);
    }
    for (int i = 1; i <= tex; i++)
        cout << sum[i];
    cout << "\n";
    return 0;
}
```

#### 位运算

##### 规律

```C++
1.求n的第k位数字: ((pp[i] >> j) & 1); // pp[i]右移j位后与1做按位且运算，既pp[i]的二进制串最后一位是1结果为1否则为0；
2.返回n的最后一位1：   lowbit(int n){ return n & (-n); }

//例子，求n的二进制表示1的个数：
int lowbit(int n){ return n & (-n); }
int main()
{
        int n,ans=0;
        cin >> n;
        while(n){        n-=lowbit(n);        ans++;         }
        cout << ans;
}
```

##### 求数组所有子集（幂集）

1. **位运算生成子集**：`1 << n` 计算出 2 的 n 次方，表示有多少个子集。对于每一个整数 i（从 0 到 2^n - 1），其二进制表示法可以直接对应一个子集的包含情况。如果二进制表示的某一位为 1，则对应位置的元素在该子集中。
2. **避免重复子集**：由于输入数组中的元素互不相同，生成的子集也不会重复，不需要额外去重。

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        int subsetCount = 1 << n; // 2^n, 总共有 2^n 个子集

        for (int i = 0; i < subsetCount; ++i) {
            vector<int> subset;
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) { // 判断第 j 位是否为 1
                    subset.push_back(nums[j]);
                }
            }
            result.push_back(subset);
        }
        
        return result;
    }
};

```



#### 前缀和差分

**还可以把初始数组全设成0，最后在加上所给数组**

1.前缀和：求区间[l,r]的和

```C++
一维：
int a[101],sum[101]={0};
for(int i=1;i<=100;i++)
        cin>>a[i];
sum[0]=a[0];  // sum[0]要进行初始化
for(int i=1;i<=100;i++)
        sum[i]=a[i]+sum[i-1];

//a[l] + ... + a[r] = S[r] - S[l - 1]
二维：
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

2.差分：一个序列中某个区间内的所有值均加上或减去一个常数 （多次操作，一次询问）

```C++
int a[100];// 设原数组为a
int b[110];// 设差分数组为b  因为r+1 要多开防止越界

b[l] += x;     b[r + 1] -= x;   //给区间[l, r]中的每个数加上c

int m = 0;
    for(int i = 0; i <= l; i++)
        m += delta[i];   //m就是原数组元素
                        //原序列就是差分序列的前缀和
int n, m, l, r, sum;
int v[100000010];
int main()
{
    ios::sync_with_stdio(0);
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        cin >> l >> r;
        v[l] += 1;
        v[r + 1] -= 1;
    }
    int a = 0;
    for (int i = 0; i <= n; i++) // n也是一个同学
    {
        a += v[i];
        if (a == 0)
            sum++;
    }
    cout << sum;
    return 0;
}
```

#### 区间合并

// 将所有存在交集的区间合并

```C++
typedef pair<int,int> PII;
vector<PII> segs;

void merge(vector<PII> &segs)
{
    vector<PII> res;
sort(segs.begin(), segs.end());

int st = -2e9, ed = -2e9;
for (auto seg : segs)
    if (ed < seg.first)
    {
        if (st != -2e9) res.push_back({st, ed});
        st = seg.first, ed = seg.second;
    }
    else ed = max(ed, seg.second);

if (st != -2e9) res.push_back({st, ed});
    
    
segs = res;}
```

#### 并查集

```C++
#include <bits/stdc++.h>
using namespace std;
#define max 1000010

int fa[max], n, m, q, a1, a2; // 这种fa初始都是0 ，还有一种初始是自己

int find(int a) // 把find(x)  理解成一个并查集的父亲，即最高祖宗
{
    return fa[a] ? fa[a] = find(fa[a]) : a;
}

int main()
{
    cin >> n >> m >> q;

    for (int i = 0; i < m; i++)
    {
        cin >> a1 >> a2;
        if (find(a1) != find(a2))
        {
            fa[a1] = a2;
        }
    }

    for (int i = 0; i < q; i++)
    {
        cin >> a1 >> a2;
        a1 = find(a1);
        a2 = find(a2);
        if (a1 != a2)
        {
            cout << "No\n";
        }
        else
        {
            cout << "Yes\n";
        }
    }
    return 0;
}
```



#### 滑动窗口

使用场景: 下面这种双层遍历，  可以改为滑动窗口   滑动窗口加map/set经常使用 

[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)这道题是用map.size()来判断条件是否成立

第一层为for(int i=0;i<size;i++)  逐个遍历

第二层从i+1开始遍历，直到满足某种条件  

```

以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；
以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。


```



####    单调队列+滑动窗口/  优先队列+滑动窗口

单调队列习惯上使用队头作为结果，那么求窗口最大值 设成递减

单调队列和单调栈 a[i] 都是要入队/栈的

```C++
//单调队列+滑动窗口
#include <bits/stdc++.h>
using namespace std;
const int MAX = 1e6 + 1;
int v[MAX];
deque<int> a;
int n, k;

int main()
{
    cin >> n >> k;
    for (int i = 0; i < n; i++)
    {
        cin >> v[i];
    }

    for (int i = 0; i < n; i++) // a队列存放i v存放数据
    {
        while (!a.empty() && v[a.back()] > v[i])
        {
            a.pop_back();
        }

        a.push_back(i); // a存放的是下标

        while (!a.empty() && a.front() < i - k + 1)
        {
            a.pop_front();
        }

        if (i >= k - 1)
        {
            cout << v[a.front()] << " ";
        }
    }
    return 0;
}

//优先队列+滑动窗口
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; ++i) {
            q.emplace(nums[i], i);
        }
        vector<int> ans = {q.top().first};
        for (int i = k; i < n; ++i) {
            q.emplace(nums[i], i);
            while (q.top().second <= i - k) {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```





#### 单调栈

解决一类涉及序列（一维数组）中元素的**相对大小**关系的问题。

单调栈通常用于找到下一个更大元素或下一个更小元素

单调递增栈为例

1. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小
2. 如果新的元素较大，就入栈

当元素出栈时，说明这个新元素是**出栈元素**向后找第一个比其小的元素

当元素出栈后，说明新栈顶元素是**出栈元素**向前找第一个比其小的元素

1526

1 5 6 3 

Sta ==1 5 6     假如3要入队 ，6 就要出栈 可以看出 5<6 而 6>3



#### 双指针

一、双指针

**双指针**是一种通过使用两个指针解决问题的技巧。根据具体问题的不同，双指针的移动方式也不同。常见的双指针问题包括：**左右指针**和**快慢指针**。

##### 1. 左右指针

- **适用场景**：一般用于数组的两端，左右指针分别从两端向中间移动，常用于排序数组、查找等问题。

  **示例：判断是否是回文串**

  - 题目：给定一个字符串，判断它是否是回文。

  ```
  cppCopy codebool isPalindrome(string s) {
      int left = 0, right = s.size() - 1;
      while (left < right) {
          if (s[left] != s[right]) {
              return false;
          }
          left++;
          right--;
      }
      return true;
  }
  ```

##### 2. 快慢指针

- **适用场景**：一般用于链表或数组中，用于判断是否有环、找中间节点等。

  **示例：寻找链表的中间节点**

  ```
  cppCopy codeListNode* middleNode(ListNode* head) {
      ListNode *slow = head, *fast = head;
      while (fast && fast->next) {
          slow = slow->next;
          fast = fast->next->next;
      }
      return slow; // 当快指针到达末尾时，慢指针正好到达中间节点
  }
  ```

#### **Floyd 判圈算法**

（Floyd’s Cycle Detection Algorithm），也叫**龟兔赛跑算法**，是一种用于检测链表或其他数据结构中是否存在环的算法。这个算法通过两个指针（一个快指针、一个慢指针）遍历链表来判断是否有环，效率较高，时间复杂度为 O(n)O(n)O(n)，空间复杂度为 O(1)O(1)O(1)。

算法思想

该算法基于以下直观想法：

- **慢指针**每次走一步，**快指针**每次走两步。
- 如果链表中存在环，快指针最终会与慢指针相遇，因为快指针会在环中追上慢指针。
- 如果链表中没有环，快指针会走到链表的末尾，指向 `NULL`。

------



## 数论

### 二进制

`n & (n - 1)` 操作将 n 的最右边的 1 变为 0

Brian Kernighan 算法：

```C++
//统计二进制中1的个数     算法适用于正数、负数以及 0
int NumberOf1(int n) {
    int count = 0;
    while (n != 0) {
        n = n & (n - 1);
        count++;
    }
    return count;
}
```

### 进制转换

将一个数N转换成x进制等于 *N*=x^m*1 + x*^m*2 + x*^mk

X 进制下的数位和 sum == m1+m2+ ..+mk

```C++
 while (n) { sum += n % 3;
             n = n / 3; }
```

如果X是奇数 那么N和K的奇偶性要相同 ，才能有非负整数序列。 （k个奇数相加结果是和k的奇偶性有关）

### 素数

判断是否是素数时

```C++
    for (int i = 2; i <= sqrt(m); i++)比  for (int i = 2; i * i <= m; i++)快
```

#### 欧拉筛

```C++
int primes[N], cnt; // primes[]存储所有素数
bool ti[N];         // st[x]存储x是否被剔除
void getPrimes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!ti[i]) {
            primes[cnt++] = i;
        }

        for (int j = 0; primes[j]*i <= n; j++) {
            ti[primes[j]*i] = true;

            if (i % primes[j] == 0) {
                break;
            }
        }
    }

    // 1.首先，任何合数都能表示成多个素数的积。所以，任何的合数肯定有一个最小质因子。我们通过这个最小质因子就可以判断什么时候不用继续筛下去了。
    // 2.当i是prime[j] 的整数倍时（i % prime[j] == 0），i * prime[j + 1] 肯定被筛过，跳出循环。
    // 因为i可以看做prime[j] *某个数， i *prime[j + 1] 就可以看做 prime[j] * 某个数 *prime[j + 1] 。
    // 而 prime[j] 必定小于 prime[j + 1]， 所以 i *prime[j + 1] 必定已经被 prime[j] * 某个数 筛掉，就不用再做了√
    
    // 同时我们可以发现在满足程序里的两个条件的时候，prime[j] 必定是prime[j] *i 的最小质因子。这个性质在某些题里可以用到。
    for (int i = 0; i < cnt; i++)
    {
        cout << primes[i] << " ";
    }
    // cout << cnt;
}
```

#### 素数分解 ？

任何一个大于1的[自然数](https://baike.baidu.com/item/自然数/385394) N,如果N不为**[质数](https://baike.baidu.com/item/质数/263515)**，那么N可以唯一分解成有限个质数的乘积；

```C++
                vector<int> a;   //分解的素数存到a中 ，并判断x是不是素数
                bool flag = false;
        for (int i = 2; i * i <= x; i++)
        {
            if (x % i == 0)
            {
                a.push_back(i);
                while (x % i == 0)
                {
                    x = x / i;
                    flag = true;
                }
            }
        }
        if (x != 1)
            a.push_back(x);
```

### 最大公约数和最小公倍数

gcd(x,y) = gcd(x-y,y) = gcd(x%y,y) 函数 __gcd(x,y)

```C++
int gcd(int a, int b)    //stl:  __gcd(x,y)
{
    return b ? gcd( b , a % b): a ;// 0和其它数的最大公约数是这个数   
}
int lcm(int x, int y)
{
    return x / gcd(x, y) * y;
}
```

### 快速幂

每一个正整数可以唯一表示为若干指数不重复的2的次幂的和

```C++
int quicksort(int a, int b)
{
    int ret = 1;
    while (b)
    {
        if (b & 1) //第一位二进制的值
        {
            ret = ret * a;
        }
        b >>= 1; 
        a = a * a; //左边一位的值
    }
     return ret;
}
```

### 多项式除法

![202407090222306](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202407111548364.png)

### 取整与取模的转换

![202407090223190](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202407111548279.png)

![202407090223068](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202407111548809.png)

## 图论

### 存储

vector<vector<int>> adj;  // 邻接表



#### 链式向前星

![202407090239219](D:\code\Drawing-bed\typora\202407090239219.png)

```C++
const int N = 1e5;
struct
{
    int u, v, l, next;
} eg[N];

int head[N], cnt;

void add_edge(int a, int b, int l)
{        cnt++;
    eg[cnt].u = a;
    eg[cnt].v = b;
    eg[cnt].l = l;
    eg[cnt].next = head[a];
    head[a] = cnt;}

void bian(int a)
{        for (int i = head[a]; i != 0; i = eg[i].next)
    {
        cout << eg[i].v << " ";
    }
}

int main()
{   add_edge(3, 2, 1);
    add_edge(2, 4, 1);
    bian(1);
    return 0;
}
```

#### 邻接矩阵

```C++
const int Max = 10000;
long long s[Max][Max]; //vector<vector<int>> adj;  // 邻接表

void add_edge(int a, int b)
{
    s[a][b] = 1;
}

bool cz(int a, int b)
{
    return s[a][b];
}

int main()
{
    int n;
    cin >> n;

    for (int i = 1; i <= n; i++)
    {
        if (s[1][i])
        {
            
        }
    }

    return 0;
}
```

#### vector邻接表

```C++
const int N = 1e5;
typedef struct
{
    int a, b;
} Edge;

vector<Edge> eg[N];

void add_edge(int a, int b)
{
    eg[a].push_back({a, b});
}

bool querr(int a, int b)
{
    for (auto i : eg[a])
    {
        if (i.b == b)
            return 1;
        return 0;
    }
}

int main()
{
    int n;
    cin >> n;

    for (auto i : eg[1])
    {
    }

    return 0;
}
```

### 搜索

DFS（深度优先搜索）和 BFS（广度优先搜索）是两种常用的**图或树**的遍历算法。它们用于遍历图中的所有节点，或者找到特定的路径。两者的遍历方式不同，适用于不同的场景。

### 1. DFS（深度优先搜索）

**思想**：从起始节点出发，尽可能沿着一个方向往下搜索，直到不能继续为止（即到达叶子节点或无邻居节点）。然后回溯到上一个节点，继续沿着其他方向进行搜索。

#### 特点：

- 使用**栈**（递归调用栈或显式栈）实现。
- 适合用于**找一条路径**或**检查是否存在路径**的场景。
- 搜索路径较“深”，有可能会陷入死胡同（但它会回溯）。

#### 应用场景：

- 检测图中的连通性。
- 寻找路径。
- 拓扑排序、解决迷宫问题、生成迷宫等。

#### 代码示例（递归版 DFS，遍历图）：

```
cppCopy codevoid dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    // 标记当前节点已访问
    visited[node] = true;

    // 处理当前节点（这里可以进行其他操作）
    cout << node << " ";

    // 遍历邻接节点
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited);
        }
    }
}
```

#### 代码示例（显式栈的非递归 DFS）：

```
cppCopy codevoid dfs(int startNode, vector<vector<int>>& graph, vector<bool>& visited) {
    stack<int> s;
    s.push(startNode);

    while (!s.empty()) {
        int node = s.top();
        s.pop();

        if (!visited[node]) {
            visited[node] = true;
            cout << node << " ";

            // 将邻居节点压入栈中
            for (int neighbor : graph[node]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
    }
}
```

### 2. BFS（广度优先搜索）

**思想**：从起始节点出发，优先访问距离起点最近的节点。遍历当前节点的所有邻居后，再继续访问这些邻居的邻居，以此类推。

#### 特点：

- 使用**队列**实现。
- 适合用于**找最短路径**的场景（无权图）。
- 搜索路径较“宽”，能快速找到离起点最近的解。

#### 应用场景：

- 找到两节点间的最短路径（无权图）。
- 在迷宫等问题中，寻找最短路径。
- 层序遍历树。

#### 代码示例（BFS，遍历图）：

```
cppCopy codevoid bfs(int startNode, vector<vector<int>>& graph, vector<bool>& visited) {
    queue<int> q;
    q.push(startNode);
    visited[startNode] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        // 处理当前节点（这里可以进行其他操作）
        cout << node << " ";

        // 遍历邻接节点
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}
```

### DFS vs BFS 的区别

| **对比维度**     | **DFS（深度优先搜索）**            | **BFS（广度优先搜索）**          |
| ---------------- | ---------------------------------- | -------------------------------- |
| **数据结构**     | 栈（递归调用栈或显式栈）           | 队列                             |
| **适合问题**     | 找到某条路径、搜索深度大的问题     | 找到最短路径、搜索广度大的问题   |
| **优先访问顺序** | 深度优先，尽可能深入探索           | 广度优先，先访问当前层的所有节点 |
| **应用场景**     | 迷宫生成、拓扑排序、路径存在性检测 | 最短路径查找、层序遍历、迷宫求解 |
| **时间复杂度**   | O(V + E)                           | O(V + E)                         |
| **空间复杂度**   | O(V) （递归深度或栈大小）          | O(V) （队列的大小）              |

总结

- **DFS**：适合用于路径存在性检测、深度较深的搜索任务，比如迷宫生成、连通分量检测等。
- **BFS**：更适合用于无权图的最短路径问题，比如迷宫求解、社交网络中最近的好友查找等。





#### 1.广度搜索

需要用到**队列**和**移动数组**

![202407090239398](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202407111549594.png)

```C++
#include <bits/stdc++.h>
using namespace std;

int g[25][25];
bool vis[25][25];

struct st
{
    int x, y;
    int dis;
};

int dirx[4] = {0, 0, 1, -1};
int diry[4] = {1, -1, 0, 0};

int bfs(int sx, int sy, int ex, int ey)
{
    queue<st> q;
    st temp;
    temp.x = sx;
    temp.y = sy;
    temp.dis = 0;
    q.push(temp);
    vis[sx][sy] = true;

    while (!q.empty())
    {
        st res = q.front();
        q.pop();
        if (res.x == ex && res.y == ey)
            return res.dis;
        for (int i = 0; i < 4; i++)
        {
            int xx = res.x + dirx[i], yy = res.y + diry[i], dist = res.dis + 1;
            if (!vis[xx][yy] && g[xx][yy] == 1)
            {
                st tmp;
                tmp.x = xx;
                tmp.y = yy;
                tmp.dis = dist;
                q.push(tmp);
                vis[xx][yy] = true;
            }
        }
    }
}

int main()
{
    int n, m;
    cin >> n >> m;
    int sx, sy, ex, ey;
    cin >> sx >> sy >> ex >> ey;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cin >> g[i][j];
        }
    }
    int ans = bfs(sx, sy, ex, ey);
    cout << ans;

    return 0;
}
```

#### 2.深度搜索/回溯法

==枚举==递推

![202407090239180](https://raw.githubusercontent.com/lanyoumeng/Drawing-bed/main/docs/202407111549565.png)

**深度优先搜索的 vis标记负数时  从 int vis[100] -->unordered_map<int,int> mm;**

```C++

int main()
{
    dfs(1);

    return 0;
}
//全排列    直接用函数next_permutation(first, last)  需要先sort()一下
int a[100010], vis[100010];

void dfs(int now, int n)
{
    if (now == n + 1)
    {
        for (int i = 1; i <= n; i++)
        {
            cout << a[i] << " ";
        }
        cout << "\n";

        return;
    }

    for (int i = 1; i <= n; i++)  //注意这里改为i=now ，起始位置不断+1    原来是6 6 6 变为6 5 4...
    {
        if (vis[i])  //不标记的话，是有重复数字的
            continue;
        vis[i] = 1;
        a[now] = i;
        dfs(now + 1, n);
        vis[i] = 0;
    }
    return;
}

int main()
{
    int n;
    cin >> n;
    dfs(1, n);

    return 0;
}

//八皇后
#include <bits/stdc++.h>
using namespace std;

int ans[10], vis[3][20]; // vis[0]标记列，vis[1]标记正对角线，vis[2]标记反对角线

// 深度优先搜索
void dfs(int now)
{
    // 递归终止条件：如果 8 个皇后都放好了，输出结果
    if (now == 9)
    {
        for (int i = 1; i <= 8; i++)
        {
            cout << ans[i] << " ";
        }
        cout << endl;
        return;
    }

    // 尝试将皇后放在当前行的每一列
    for (int i = 1; i <= 8; i++)
    {
        // 如果当前列或对角线已经有皇后，则跳过
        if (vis[0][i] || vis[1][now + i] || vis[2][now - i + 8])
            continue;

        // 记录当前行的皇后位置
        ans[now] = i;

        // 标记当前列、正对角线、反对角线
        vis[0][i] = 1;
        vis[1][now + i] = 1;
        vis[2][now - i + 8] = 1;

        // 递归处理下一行
        dfs(now + 1);

        // 回溯，撤销标记
        vis[0][i] = 0;
        vis[1][now + i] = 0;
        vis[2][now - i + 8] = 0;
    }
}

int main()
{
    // 从第 0 行开始进行深度优先搜索
    dfs(1);

    return 0;
}
```

### 拓扑排序

有向无环图才有拓扑排序 拓扑排序是图的所有顶点的一个排列（所有点出现且仅出现一次）

 如果图中有点A->B 那么在拓扑排序中点A的位置一定在点B前面 

时间复杂度O(N) 

拓扑排序的应用：

1. 有向图找环 （能找到拓扑排序说明没有环）
2. 解决依赖问题 （用A->B表示B依赖A，以此建图，找到的拓扑排序里A一定在B之前完成）[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)

```Bash
void topological_sort(int n) //// 顶点数量
{
    queue<int> q;

    // 将所有入度为0的顶点入队
    for (int i = 1; i <= n; i++)
    {
        if (in[i] == 0)
        {
            q.push(i);
        }
    }

    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        cout << u << " "; // 输出拓扑排序的顶点

        // 遍历从顶点u出发的所有边
        for (int i = head[u]; i != -1; i = eg[i].pre)
        {
            int v = eg[i].v;
            in[v]--; // 顶点v的入度减少
            if (in[v] == 0)
            {
                q.push(v);
            }
        }
    }
}
```

### 最短路

从一个顶点到另一个顶点存在很多路径，最短的那条叫做最短路

最短路算法：

Bellman-Ford、SPFA //可以处理负边

Dĳkstra //不可以处理负边 A*算法（看）

Floyd //可以处理负边

#### 多源最短路floyd

```C++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
            }
        }
    }

    return 0;
}
```

#### 堆优化Dijkstra 单源最短路

复杂度= O(NlogM)

可求源节点到每个节点的最短路

有向图的边权值全为非负数

```C++
#include <vector>
#include <queue>
#include <limits>

struct Edge {
    int to;
    int weight;
};

void dijkstra(int start, const vector<vector<Edge>>& graph, vector<int>& dist) {
    int n = graph.size();
        dist.assign(n, std::numeric_limits<int>::max());  // 初始化距离为无穷大
    dist[start] = 0;

    // 使用优先队列（最小堆）存储 <距离, 节点>
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        // 如果当前距离大于已记录的距离，则跳过
        if (d > dist[u]) continue;

        // 遍历邻接边
        for (const Edge& edge : graph[u]) {
            int v = edge.to;
            int weight = edge.weight;

            // 如果通过 u 点到 v 点的距离比当前记录的距离小，则更新
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}



#include <bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f;
const int N = 1e5;
struct Edge
{
    int u, v, next, l;
};

Edge eg[N];
int head[N], cnt;

int d[N];    // 源点s到i的最短路径
bool vis[N]; // 是否选过了

void dijk(int s)
{
    memset(d, 0x3f3f3f3f, sizeof(d));
    d[s] = 0;

    typedef pair<int, int> pii, mii;
    priority_queue<pii, vector<pii>, greater<pii>> q;

    q.push(mii(0, s)); // 初始化，最小的待计算的临时节点就是源点
    while (!q.empty()) // 临时节点为空代表
    {
        int u = q.top().second; // 待计算的临时节点中最小的
        q.pop();
        if (vis[u]) // 是永久节点就不用再运算了
            continue;
        vis[u] = 1;                              // 标记为永久节点
        for (int i = head[u]; i; i = eg[i].next) // 拷问该临时节点的邻居
        {
            int v = eg[i].v;
            int l = eg[i].l;
            if (d[v] > d[u] + l) // 更新邻居的数据，再把邻居加入到待计算的临时节点
            {
                d[v] = d[u] + l;
                q.push(mii(d[v], v));
            }
        }
    }
}

int main()
{

    return 0;
}
```

#### SPFA单源最短路

O(NM)

可以处理有向图和无向图，但不能处理负权回路。

```C++
#include <bits/stdc++.h>
using namespace std;
const int Max = 1000010;
struct Edge
{
       int u, v, next, l;
};
int head[Max];
Edge eg[Max];
int d[Max];
bool inq[Max];

void spfa(int s)
{

       memset(d, 0x3f3f3f3f, sizeof(d));
       d[s] = 0;

       queue<int> q; // 队列用来保存待优化的结点
       q.push(s);
       inq[s] = true;

       while (!q.empty())
       {
              int u = q.front();
              q.pop();
              inq[u] = false;

              for (int i = head[u]; i; i = eg[i].next)
              {
                     int v = eg[i].v;
                     int l = eg[i].l;
                     if (d[v] > d[u] + l)
                     {
                            d[v] = d[u] + l;
                            if (!inq[v])
                            {
                                   q.push(v);
                                   inq[v] = true;
                            }
                     }
              }
       }
}
int main()
{

       return 0;
}
```

## 动态规划

动态规划是一种通过将复杂问题分解为更小的子问题来解决问题的方法。它的核心思想是避免重复计算，通过存储子问题的解来提高效率。

### 关键概念

1. 最优子结构（Optimal Substructure）： 如果问题的最优解可以通过子问题的最优解来构建，则该问题具有最优子结构性质。
2. **重叠子问题**（Overlapping Subproblems）： 动态规划的一个主要特征是重叠子问题，即子问题会被多次计算。通过存储这些子问题的解，可以避免重复计算。
3. **状态转移方程**（State Transition Equation）： 状态转移方程描述了如何从一个或多个子问题的解构造出原问题的解。它是动态规划的核心。
4. 初始条件（Base Case）： 动态规划需要明确初始条件，即最小的子问题的解。即**初始化第一个特殊情况**
5. **填充 dp 数组(一维)/表格(二维)** ， `dp[i]` 和 `dp[i][j]` 通常用于表示某个问题的**状态**或**子问题的解**

   1. 有时为了避免重复，会从后往前遍历

   2. **常见示例**：

      - ***最大子序和**：*f*(*i*) 代表以第 *i* 个数结尾的「连续子数组的最大和」 f(i)=max{ f(i−1)+*nums*[*i*] ,  *nums*[i]}

      - **最长上升子序列**：`dp[i]` 表示以元素 `i` 结尾的最长上升子序列的长度。

      - **斐波那契数列**：`dp[i]` 表示第 `i` 个斐波那契数。

      - **背包问题**：`dp[i]` 表示在容量为 `i` 的背包中可以装下的最大价值。

      - 

      - **最长公共子序列**：`dp[i][j]` 表示字符串 `A` 的前 `i` 个字符和字符串 `B` 的前 `j` 个字符之间的最长公共子序列的长度。

        **编辑距离**：`dp[i][j]` 表示将字符串 `A` 的前 `i` 个字符转换成字符串 `B` 的前 `j` 个字符所需的最小编辑距离。

        **背包问题（二维）**：`dp[i][j]` 表示前 `i` 个物品放入容量为 `j` 的背包时的最大价值。


```Bash
元素不能相邻选，f[i]前i个满足条件最大  f[i-2]+w[i] 和f[i-1]  //198. 打家劫舍

最长递增子序列 dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，注意 nums[i]必须被选取。

当前位置的最优解未必是由前一个位置的最优解转移得到的。 //152. 乘积最大子数组


```

### 背包问题

```C++
//01背包
#include <bits/stdc++.h>
using namespace std;

int N, V;
int f[10001][10001];
int v[10001], w[10001];

int main()
{
    cin >> N >> V;
    for (int i = 1; i <= N; i++)
    {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= N; i++)
    {
        for (int j = 0; j <= V; j++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i])
            {
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    cout << f[N][V];

    return 0;
}

// 完全背包
#include <bits/stdc++.h>
using namespace std;

int N, V;
int f[10001][10001];
int v[10001], w[10001];

int main()
{
    cin >> N >> V;
    for (int i = 1; i <= N; i++)
    {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <=N; i++)
    {
        for (int j = 0; j <= V; j++)
        {
            f[i][j]=f[i-1][j];
            if (j >= v[i])
            {

                f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i]);   //只是把i-1改为i
            }
        }
    }
    cout<<f[N][V];

    return 0;
}
```

## 其它

### 关闭同步流

ios::sync_with_stdio(0); cin.tie(0),cout.tie(0);

